{"ast":null,"code":"export default function (p) {\n  // p.Range = (p.TotalVelocity * p.TotalVelocity * Math.sin(2 * p.theta)) / p.g;\n  var reset = function reset() {\n    p.myCustomRedrawAccordingToNewPropsHandler = function (props) {\n      if (props.p5Props) {\n        p.ButtonClicked = props.p5Props.start;\n        p.ButtonClickedR = props.p5Props.reset;\n        p.radius = Number(props.p5Props.radius); // also input\n\n        p.degree = Number(props.p5Props.degree);\n        p.theta = p.degree * Math.PI / 180;\n        p.x1 = p.radius;\n        p.y1 = p.windowHeight / 1.5 - p.radius;\n        p.TotalVelocity = Number(props.p5Props.velocity); //this is tha canvas limit\n\n        p.Vx = p.TotalVelocity * Math.cos(p.theta);\n        p.Vy = p.TotalVelocity * Math.sin(p.theta);\n        p.g = Number(props.p5Props.Gravitational); // we will let put the variable g as stronger gravity planets\n        //input\n        //console.log(props.p5Props);\n      }\n    };\n  };\n\n  p.preload = function () {\n    reset();\n  };\n\n  p.windowResized = function () {\n    p.resizeCanvas(p.windowWidth / 1.5, p.windowHeight / 1.5);\n  };\n\n  p.setup = function () {\n    p.createCanvas(p.windowWidth / 1.5, p.windowHeight / 1.5);\n  };\n\n  p.draw = function () {\n    p.background(200, 250, 100);\n    p.noStroke();\n    p.ellipseMode(p.CENTER);\n    p.fill(\"blue\");\n    p.ellipse(p.x1, p.y1, p.radius * 2, p.radius * 2);\n\n    if (p.ButtonClicked) {\n      ProjectileVector();\n    } else if (!p.ButtonClicked && p.ButtonClickedR) {\n      reset();\n    }\n  };\n\n  var ProjectileVector = function ProjectileVector() {\n    if (p.x1 > p.width - p.radius || p.y1 > p.height - p.radius) {\n      p.background(0);\n      p.Vy = 0;\n      p.Vx = 0;\n    } else {\n      p.x1 += p.Vx;\n      p.Vy = p.Vy - p.g / 60;\n      p.y1 -= p.Vy;\n    } //beacuse our coordinates works in opposite direction\n    //console.log(p.x1,p.y1);\n\n  };\n}","map":{"version":3,"sources":["C:\\Users\\Mgo\\PhpstormProjects\\untitled\\src\\Component\\sketch2.js"],"names":["p","reset","myCustomRedrawAccordingToNewPropsHandler","props","p5Props","ButtonClicked","start","ButtonClickedR","radius","Number","degree","theta","Math","PI","x1","y1","windowHeight","TotalVelocity","velocity","Vx","cos","Vy","sin","g","Gravitational","preload","windowResized","resizeCanvas","windowWidth","setup","createCanvas","draw","background","noStroke","ellipseMode","CENTER","fill","ellipse","ProjectileVector","width","height"],"mappings":"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","sourcesContent":["export default function(p) {\r\n  // p.Range = (p.TotalVelocity * p.TotalVelocity * Math.sin(2 * p.theta)) / p.g;\r\n  const reset = () => {\r\n    p.myCustomRedrawAccordingToNewPropsHandler = function(props) {\r\n      if (props.p5Props) {\r\n        p.ButtonClicked = props.p5Props.start;\r\n        p.ButtonClickedR = props.p5Props.reset;\r\n        p.radius = Number(props.p5Props.radius); // also input\r\n        p.degree = Number(props.p5Props.degree);\r\n        p.theta = (p.degree * Math.PI) / 180;\r\n        p.x1 = p.radius;\r\n        p.y1 = p.windowHeight / 1.5 - p.radius;\r\n        p.TotalVelocity = Number(props.p5Props.velocity); //this is tha canvas limit\r\n        p.Vx = p.TotalVelocity * Math.cos(p.theta);\r\n        p.Vy = p.TotalVelocity * Math.sin(p.theta);\r\n        p.g = Number(props.p5Props.Gravitational); // we will let put the variable g as stronger gravity planets\r\n        //input\r\n        //console.log(props.p5Props);\r\n      }\r\n    };\r\n  };\r\n\r\n  p.preload = () => {\r\n    reset();\r\n  };\r\n\r\n  p.windowResized = () => {\r\n    p.resizeCanvas(p.windowWidth / 1.5, p.windowHeight / 1.5);\r\n  };\r\n  p.setup = () => {\r\n    p.createCanvas(p.windowWidth / 1.5, p.windowHeight / 1.5);\r\n  };\r\n\r\n  p.draw = () => {\r\n    p.background(200, 250, 100);\r\n    p.noStroke();\r\n    p.ellipseMode(p.CENTER);\r\n    p.fill(\"blue\");\r\n    p.ellipse(p.x1, p.y1, p.radius * 2, p.radius * 2);\r\n\r\n    if (p.ButtonClicked) {\r\n      ProjectileVector();\r\n    } else if (!p.ButtonClicked && p.ButtonClickedR) {\r\n      reset();\r\n    }\r\n  };\r\n\r\n  const ProjectileVector = () => {\r\n    if (p.x1 > p.width - p.radius || p.y1 > p.height - p.radius) {\r\n      p.background(0);\r\n      p.Vy = 0;\r\n      p.Vx = 0;\r\n    } else {\r\n      p.x1 += p.Vx;\r\n      p.Vy = p.Vy - p.g / 60;\r\n      p.y1 -= p.Vy;\r\n    } //beacuse our coordinates works in opposite direction\r\n\r\n    //console.log(p.x1,p.y1);\r\n  };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}